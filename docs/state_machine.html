<!DOCTYPE html>

<html>
<head>
  <title>State machine support for task.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="channel.html">
                channel.js
              </a>
            
              
              <a class="source" href="state_machine.html">
                state_machine.js
              </a>
            
              
              <a class="source" href="task.html">
                task.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="state-machine-support-for-task-js">State machine support for task.js</h1>
<p>This file contains miscellaneous state machine management code
that is used by the code generated by the <code>task</code> macro in task.js.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> nextTick = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.setImmediate || process.nextTick;
}());

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">State</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.id = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.args = [<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>];
    <span class="hljs-keyword">this</span>.err = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.unwinding = [];
    <span class="hljs-keyword">this</span>.waiting = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.isFinished = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.isUnwinding = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.currentErrorStep = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.abort_with_error = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">controlAPIMaker</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> state_machine = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.create({}, {
        abort: {
            value: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span>
                <span class="hljs-keyword">if</span> (state_machine.state.waiting &gt; <span class="hljs-number">0</span>) {
                    state_machine.state.abort_with_error = err;
                } <span class="hljs-keyword">else</span> {
                    state_machine.callback(err);
                }
            }
        },
        isWaiting: {
            get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
                <span class="hljs-keyword">return</span> state_machine.state.waiting &gt; <span class="hljs-number">0</span>;
            }
        },
        isFinished: {
            get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
                <span class="hljs-keyword">return</span> state_machine.state.isFinished;
            }
        }
    });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">StateMachine</span><span class="hljs-params">(context, callback, fn, task_fn)</span> {</span>

    <span class="hljs-keyword">this</span>.state = <span class="hljs-keyword">new</span> State();
    <span class="hljs-keyword">this</span>.fn = fn;
    <span class="hljs-keyword">this</span>.task_fn = task_fn;
    <span class="hljs-keyword">this</span>.context = context;
    <span class="hljs-keyword">this</span>.finalCallback = callback;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>The following two will be initialized if the body
of the state machine contains a finally {} block.
If not, they can remain null.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.captureStateVars = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Might be initialized to function () { return array; }</span>
    <span class="hljs-keyword">this</span>.restoreStateVars = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Might be initialized to function (array) { assign state variables; }</span>

    <span class="hljs-keyword">this</span>.boundStep = <span class="hljs-keyword">this</span>.step.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.boundUnwind = <span class="hljs-keyword">this</span>.unwind.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.controlAPIMaker = controlAPIMaker.bind(<span class="hljs-keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Initialize the jump table structure if not done already.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.task_fn.cachedJumpTable = <span class="hljs-keyword">this</span>.task_fn.cachedJumpTable || {};

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}

StateMachine.prototype.start = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.goTo(<span class="hljs-number">1</span>);
};

StateMachine.prototype.step = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.state.waiting--;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.abort_with_error) {
        <span class="hljs-keyword">this</span>.performAbort();
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.fn.apply(<span class="hljs-keyword">this</span>.context, <span class="hljs-keyword">this</span>.state.args);
    }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>If an abortion has been requested by the state machine
user, then bail out on the next step.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>StateMachine.prototype.performAbort = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> err = <span class="hljs-keyword">this</span>.state.abort_with_error;
    <span class="hljs-keyword">this</span>.state.abort_with_error = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.fn.call(<span class="hljs-keyword">this</span>.context, err);
};

StateMachine.prototype.goTo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id)</span> {</span>
    <span class="hljs-keyword">this</span>.state.id = id;
    <span class="hljs-keyword">this</span>.state.waiting++;
    nextTick(<span class="hljs-keyword">this</span>.boundStep);
};

StateMachine.prototype.thenTo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id)</span> {</span>
    <span class="hljs-keyword">var</span> done = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.state.waiting++;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> _self = self;
        <span class="hljs-keyword">var</span> _state = _self.state;
        _state.waiting--;
        <span class="hljs-keyword">if</span> (!done) {
            done = <span class="hljs-literal">true</span>;
            _state.id = id;
            <span class="hljs-keyword">if</span> (_state.abort_with_error) {
                _self.performAbort();
            } <span class="hljs-keyword">else</span> {
                _self.fn.apply(_self.context, <span class="hljs-built_in">arguments</span>); 
            }
        } <span class="hljs-keyword">else</span> {
            console.error(<span class="hljs-string">'Callback called repeatedly!'</span>);
        }
    };
};

StateMachine.prototype.callback = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span>
    <span class="hljs-keyword">this</span>.state.args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">this</span>.state.err = err;
    nextTick(<span class="hljs-keyword">this</span>.boundUnwind);
};

StateMachine.prototype.unwind = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.unwinding.length &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> where = <span class="hljs-keyword">this</span>.state.unwinding.pop();
        <span class="hljs-keyword">this</span>.state.isUnwinding = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (where.restoreState) {
            <span class="hljs-keyword">this</span>.restoreStateVars(where.restoreState);
            <span class="hljs-keyword">this</span>.unwind();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (where.retry) {
            <span class="hljs-keyword">this</span>.goTo(where.retry);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (where.phi) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.err) {
                nextTick(<span class="hljs-keyword">this</span>.boundUnwind);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">this</span>.goTo(where.phi);
            }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (where.isError) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.err) {
                <span class="hljs-keyword">this</span>.state.currentErrorStep = where;
                <span class="hljs-keyword">this</span>.goTo(where.step);
            } <span class="hljs-keyword">else</span> {
                nextTick(<span class="hljs-keyword">this</span>.boundUnwind);
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (where.fn) {
                where.fn();
                nextTick(<span class="hljs-keyword">this</span>.boundUnwind);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">this</span>.beginCleanup(where.state);
                <span class="hljs-keyword">this</span>.goTo(where.step);
            }
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.state.isFinished) {
        <span class="hljs-keyword">this</span>.state.waiting = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">this</span>.state.isFinished = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">this</span>.finalCallback &amp;&amp; <span class="hljs-keyword">this</span>.finalCallback.apply(<span class="hljs-keyword">this</span>.context, <span class="hljs-keyword">this</span>.state.args);
    }
};

StateMachine.prototype.pushCleanupAction = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(context, fn, args)</span> {</span>
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    self.state.unwinding.push({
        cleanup: <span class="hljs-literal">true</span>,
        fn: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
            fn.apply(context, args);
        }
    });
};

StateMachine.prototype.pushCleanupStep = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, afterID)</span> {</span>
    <span class="hljs-keyword">this</span>.state.unwinding.push({cleanup: <span class="hljs-literal">true</span>, step: id, state: <span class="hljs-keyword">this</span>.captureStateVars()});
    <span class="hljs-keyword">this</span>.goTo(afterID);
};

StateMachine.prototype.pushErrorStep = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, retryID)</span> {</span>
    <span class="hljs-keyword">this</span>.state.unwinding.push({isError: <span class="hljs-literal">true</span>, step: id, retryStep: retryID, unwindPoint: <span class="hljs-keyword">this</span>.state.unwinding.length});
    <span class="hljs-keyword">this</span>.goTo(retryID);
};

StateMachine.prototype.beginCleanup = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(state)</span> {</span>
    <span class="hljs-keyword">this</span>.state.unwinding.push({restoreState: <span class="hljs-keyword">this</span>.captureStateVars()});
    <span class="hljs-keyword">this</span>.restoreStateVars(state);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Retry will place the error handler again on the error stack
and jump to the beginning of the code block that previously
generated the error. Presumably, some corrective actions have
been taken already.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>StateMachine.prototype.retry = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.state.currentErrorStep) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'SyntaxError: retry statement can only be used within catch blocks'</span>);
    }

    <span class="hljs-keyword">var</span> errorStep = <span class="hljs-keyword">this</span>.state.currentErrorStep;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Finally clauses might need to run between the start of the error handler
and the current retry statement. So we need to unwind through the
finally clauses before stepping out of the catch block. To do this,
insert a plain jump into the unwind sequence at the appropriate
point. And of course, we also restore the error step description
object on the unwind stack so that the surrounding catch block will
attempt to handle any new errors that may occur.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.state.unwinding.splice(errorStep.unwindPoint, <span class="hljs-number">0</span>, errorStep, {retry: errorStep.retryStep});</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Enter a “no error” state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.state.currentErrorStep = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">this</span>.state.err = <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Begin unwinding through the finallies.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.phi();
};</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>A note on semantics. phi used to be a separate stack, which meant
that finally blocks that occur within while loops would all execute
at the end of the while loop only. This is, in general, not desirable
and it is useful to have the finally code executed once for each
scope. For this reason, it is better to have the same unwinding
stack also handle the phi jumps so that error handling code gets
to run as soon as possible.</p>
<p>Currently, if-then-else, while and switch blocks all delimit scopes
for execution of finally handlers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
StateMachine.prototype.pushPhi = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, captureState)</span> {</span>
    <span class="hljs-keyword">this</span>.state.unwinding.push({phi: id, state: (captureState ? <span class="hljs-keyword">this</span>.captureStateVars() : <span class="hljs-literal">null</span>)});
};

StateMachine.prototype.phi = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    nextTick(<span class="hljs-keyword">this</span>.boundUnwind);
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">JumpTable</span><span class="hljs-params">(id, cases, blockSizes)</span> {</span>
    <span class="hljs-keyword">this</span>.id = id;
    <span class="hljs-keyword">this</span>.cases = cases;
    <span class="hljs-keyword">this</span>.blockSizes = blockSizes;
    <span class="hljs-keyword">this</span>.stepIDs = [];
    <span class="hljs-keyword">this</span>.beyondID = id;

    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, sum = id + <span class="hljs-number">1</span>, ci;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; blockSizes.length; ++i) {
        ci = cases[i];
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; ci.length; ++j) {
            <span class="hljs-keyword">this</span>.stepIDs[ci[j]] = sum;
        }
        sum += <span class="hljs-number">1</span> + blockSizes[i]; <span class="hljs-comment">// +1 for the additional "phi"</span>
    }

    <span class="hljs-keyword">this</span>.beyondID = sum;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}

JumpTable.prototype.jumpToCase = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(sm, caseVal)</span> {</span>
    sm.pushPhi(<span class="hljs-keyword">this</span>.beyondID);
    <span class="hljs-keyword">var</span> stepID = <span class="hljs-keyword">this</span>.stepIDs[caseVal];
    <span class="hljs-keyword">if</span> (!stepID) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Unhandled case '"</span> + caseVal + <span class="hljs-string">"' at step "</span> + <span class="hljs-keyword">this</span>.id);
    }
    sm.goTo(stepID);
};

StateMachine.prototype.jumpTable = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, cases, blockSizes)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>cases[i] is an array of case values that all map
to the same block whose size is given by blockSizes[i].</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!cases) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.task_fn.cachedJumpTable[id];
    }

    console.assert(cases.length === blockSizes.length);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.task_fn.cachedJumpTable[id] = <span class="hljs-keyword">new</span> JumpTable(id, cases, blockSizes);
};


module.exports = StateMachine;</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
